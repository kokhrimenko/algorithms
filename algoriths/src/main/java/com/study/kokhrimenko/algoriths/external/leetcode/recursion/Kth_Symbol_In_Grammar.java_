package com.study.kokhrimenko.algoriths.external.leetcode.recursion;

/**
 * On the first row, we write a 0. Now in every subsequent row, we look at the
 * previous row and replace each occurrence of 0 with 01, and each occurrence of
 * 1 with 10.
 * 
 * Given row N and index K, return the K-th indexed symbol in row N. (The values
 * of K are 1-indexed.) (1 indexed).
 * 
 * Examples: Input: N = 1, K = 1 Output: 0
 * 
 * Input: N = 2, K = 1 Output: 0
 * 
 * Input: N = 2, K = 2 Output: 1
 * 
 * Input: N = 4, K = 5 Output: 1
 * 
 * Explanation:
 * row 1: 0
 * row 2: 01
 * row 3: 0110
 * row 4: 0110 1001
 * row 5: 0110 1001 1001 0110
 * row 6: 0110 1001 1001 0110 1001 0110 0110 1001
 * row 7: 0110 1001 1001 0110 1001 0110 0110 1001 1001 0110 0110 1001 0110 1001 1001 0110
 * 
 * Note:
 * - N will be an integer in the range [1, 30].
 * - K will be an integer in the range [1, 2^(N-1)].
 * 
 * @author kostic
 *
 */
public class Kth_Symbol_In_Grammar {
	public static void main(String[] args) {
		int N = 5, K = 8;
		Kth_Symbol_In_Grammar executor = new Kth_Symbol_In_Grammar();
		int result = executor.kthGrammar(N, K);
		System.out.println(result);
	}

	public int kthGrammar(int N, int K) {
		int baseN = 8;
		if (N == 0) {
			return 0;
		}
		int[] sequence = generateRow(baseN, 1, new int[] { 0 });
		if (N <= baseN) {
			return sequence == null || sequence.length < K ? 0 : sequence[K - 1];
		}

		int interestedSequence = (((K - 1) / baseN + 1) % 2);
		if (interestedSequence == 1) {
			for (int i = 0; i < sequence.length; i++) {
				sequence[i] = sequence[i] == 1 ? 0 : 1;
			}
		}
		return sequence[(K -1)% baseN ];
	}
	
	private int[] generateRow(int n, int currentIteration, int[] resultedArr) {
		if(n == currentIteration) {
			return resultedArr;
		}
		
		int[] result = new int[2 * resultedArr.length];
		for(int i=0; i<resultedArr.length; i++) {
			if(resultedArr[i] == 0) {
				result[2 * i] = 0;
				result[2 * i + 1] = 1;
			} else {
				result[2 * i] = 1;
				result[2 * i + 1] = 0;
			}
		}
		
		return generateRow(n, currentIteration +1 , result);
	}
}
